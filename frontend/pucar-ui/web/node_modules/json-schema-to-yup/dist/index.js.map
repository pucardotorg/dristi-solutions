{"version":3,"file":"index.js","sources":["../src/types/defaults/json-schema.js","../src/types/defaults/index.js","../src/types/defaults/type-def.js","../src/create-entry.js","../src/types/_loggable.js","../src/types/_type-matcher.js","../src/types/base.js","../src/types/mixed.js","../src/types/array.js","../src/types/boolean.js","../src/types/number/range-constraint.js","../src/types/constraints/numeric.js","../src/types/constraints/base.js","../src/types/number/guard.js","../src/types/_guard.js","../src/types/number/index.js","../src/types/object.js","../src/types/string.js","../src/types/date.js","../src/entry.js","../src/validator-bridge/index.js","../src/index.js"],"sourcesContent":["const defaults = {\n  getProps: obj => obj && obj.properties,\n  getType: obj => obj && obj.type,\n  getName: obj => (obj && obj.name) || obj.title,\n  getConstraints: obj => obj,\n  isString: obj => obj && obj.type === \"string\",\n  isArray: obj => obj && obj.type === \"array\",\n  isInteger: obj => (obj && obj.type === \"integer\") || obj.type === \"int\",\n  isBoolean: obj => obj && obj.type === \"boolean\",\n  hasDateFormat: obj =>\n    obj && [\"date\", \"date-time\"].find(t => t === obj.format),\n  isDate: obj =>\n    obj && obj.type === \"string\" && defaults.hasDateFormat(obj.format),\n  isNumber: obj => obj && (obj.type === \"number\" || defaults.isInteger(obj)),\n  isObject: obj => obj && obj.type === \"object\",\n  isRequired: obj => obj && obj.required\n};\n\nexport default defaults;\n","import jsonSchemaDefaults from \"./json-schema\";\nimport typeDefDefaults from \"./type-def\";\n\nconst defaults = {\n  \"json-schema\": jsonSchemaDefaults,\n  \"type-def\": typeDefDefaults\n};\n\nexport default defaults","const defaults = {\n  getProps: obj => obj && obj.fields,\n  getType: obj => obj && obj.type,\n  getName: obj => obj && obj.name,\n  getConstraints: obj => (obj && (obj.directives || {}).constraints) || {},\n  isString: obj => obj && obj.type === \"String\",\n  isArray: obj => obj && obj.isList,\n  isInteger: obj => obj && obj.type === \"Int\",\n  isBoolean: obj => obj && obj.type === \"Boolean\",\n  isDate: obj => (obj && obj.type === \"Date\") || obj.directives.date,\n  isNumber: obj => (obj && obj.type === \"Int\") || obj.type === \"Float\",\n  isObject: obj => obj && obj.type === \"Object\",\n  isRequired: obj => obj && !obj.isNullable\n};\n\nexport default defaults;\n","function createYupSchemaEntry({ name, key, value, config }) {\n  const { YupSchemaEntry } = config || {};\n  if (!YupSchemaEntry) {\n    throw \"missing YupSchemaEntry class in config\";\n  }\n  return new YupSchemaEntry({\n    name,\n    key,\n    value,\n    config\n  }).toEntry();\n}\n\nexport {\n  createYupSchemaEntry\n};\n","class Loggable {\n  constructor(config = {}) {\n    const { log, error } = config;\n    const enable = config.enable || {};\n    this.enable = enable;\n    // what type of logger to use\n    this.log = typeof log === \"function\" ? log : console.log;\n    this.err = typeof error === \"function\" ? error : console.error;\n  }\n\n  error(errMsg, value) {\n    // only disable if directly disabled\n    if (this.enable.error === false) return;\n    this.err && (value ? this.err(errMsg, value) : this.err(errMsg));\n    throw errMsg;\n  }\n\n  warn(warnMsg, value) {\n    if (!this.enable.warn) return;\n    this.logInfo(\"WARNING: \" + warnMsg, value);\n  }\n\n  logInfo(name, value) {\n    if (!this.enable.log) return;\n    this.log && (value ? this.log(name, value) : this.log(name));\n  }\n}\n\nexport {\n  Loggable\n};\n","import { Loggable } from './_loggable';\n\nclass TypeMatcher extends Loggable {\n  constructor(config = {}) {\n    super(config);\n  }\n\n  isNothing(val) {\n    return val === undefined || val === null;\n  }\n\n  isPresent(num) {\n    return !this.isNothing(num);\n  }\n\n  toNumber(num) {\n    return Number(num);\n  }\n\n  isNumberLike(num) {\n    return !isNaN(this.toNumber(num));\n  }\n\n  isNumberType(num) {\n    return !isNaN(num);\n  }\n\n  isStringType(val) {\n    return typeof val === \"string\";\n  }\n\n  isFunctionType(val) {\n    return typeof val === \"function\";\n  }\n\n  isDateType(val) {\n    return val instanceof Date;\n  }\n}\n\nexport {\n  TypeMatcher\n};\n","import defaults from './defaults';\nimport { createYupSchemaEntry } from '../create-entry';\nimport { TypeMatcher } from './_type-matcher';\n\nclass Base extends TypeMatcher {\n  constructor(config = {}) {\n    super(config);\n    config = {\n      createYupSchemaEntry,\n      ...config\n    };\n    const schemaType = config.schemaType || \"json-schema\";\n    const $defaults = defaults[schemaType];\n    this.config = { ...$defaults, ...config };\n  }\n}\n\nexport {\n  Base\n};\n","import * as yup from 'yup';\n\nclass ConvertYupSchemaError extends Error {}\n\nconst errValKeys = [\n  \"oneOf\",\n  \"enum\",\n  \"required\",\n  \"notRequired\",\n  \"minDate\",\n  \"min\",\n  \"maxDate\",\n  \"max\",\n  \"trim\",\n  \"lowercase\",\n  \"uppercase\",\n  \"email\",\n  \"url\",\n  \"minLength\",\n  \"maxLength\",\n  \"pattern\",\n  \"matches\",\n  \"regex\",\n  \"integer\",\n  \"positive\",\n  \"minimum\",\n  \"maximum\"\n];\n\nconst defaults = {\n  errMessages: (keys = errValKeys) =>\n    keys.reduce((acc, key) => {\n      const fn = ({ key, value }) =>\n        `${key}: invalid for ${value.name || value.title}`;\n      acc[key] = fn;\n      return acc;\n    }, {})\n};\n\nimport { Base } from './base';\n\nclass YupMixed extends Base {\n  constructor({ key, value, config } = {}) {\n    super(config);\n    this.validateOnCreate(key, value);\n    this.yup = yup;\n    this.key = key;\n    this.value = value;\n    this.constraints = this.getConstraints();\n    this.format = value.format || this.constraints.format;\n    this.config = config || {};\n    this.type = \"mixed\";\n    this.base = yup.mixed();\n    this.errMessages = config.errMessages || {};\n    this.constraintsAdded = {};\n\n    // rebind: ensure this always mapped correctly no matter context\n    this.rebind(\"addConstraint\", \"addValueConstraint\");\n  }\n\n  rebind(...methods) {\n    methods.map(name => {\n      const method = this[name];\n      this[name] = this.isFunctionType(method) ? method.bind(this) : method;\n    });\n  }\n\n  validateOnCreate(key, value) {\n    if (!key) {\n      this.error(\"create: missing key\");\n    }\n    if (!value) {\n      this.error(\"create: missing value\");\n    }\n  }\n\n  // override for each type\n  get enabled() {\n    [];\n  }\n\n  convertEnabled() {\n    this.enabled.map(name => {\n      if (this[name]) {\n        this[name]();\n      }\n    });\n  }\n\n  getConstraints() {\n    return this.config.getConstraints(this.value);\n  }\n\n  createSchemaEntry() {\n    return this.convert().base;\n  }\n\n  convert() {\n    this.addMappedConstraints();\n    this.oneOf().notOneOf();\n    return this;\n  }\n\n  addValueConstraint(propName, { constraintName, errName } = {}) {\n    return this.addConstraint(propName, {\n      constraintName,\n      value: true,\n      errName\n    });\n  }\n\n  addConstraint(propName, { constraintName, method, value, errName } = {}) {\n    const propValue = this.constraints[propName];\n    if (propValue) {\n      constraintName = constraintName || propName;\n      method = method || constraintName;\n      if (!this.base[method]) {\n        this.warn(`Yup has no such API method: ${method}`);\n        return this;\n      }\n      const constraintFn = this.base[method].bind(this.base);\n      const errFn =\n        this.valErrMessage(constraintName) ||\n        (errName && this.valErrMessage(errName));\n      const constraintValue = value === true ? propValue : value;\n      this.onConstraintAdded({ name: constraintName, value: constraintValue });\n\n      const newBase = constraintValue\n        ? constraintFn(constraintValue, errFn)\n        : constraintFn(errFn);\n      this.base = newBase || this.base;\n    }\n    return this;\n  }\n\n  onConstraintAdded({ name, value }) {\n    this.constraintsAdded[name] = value;\n    return this;\n  }\n\n  addMappedConstraints() {\n    const $map = this.constraintsMap;\n    const keys = Object.keys($map);\n    keys.map(key => {\n      const list = $map[key];\n      const fnName = key === \"value\" ? \"addValueConstraint\" : \"addConstraint\";\n      list.map(this[fnName]);\n    });\n    return this;\n  }\n\n  get constraintsMap() {\n    return {\n      simple: [\"required\", \"notRequired\", \"nullable\"],\n      value: [\"default\", \"strict\"]\n    };\n  }\n\n  oneOf() {\n    const value = this.constraints.enum || this.constraints.oneOf;\n    return this.addConstraint(\"oneOf\", { value, errName: \"enum\" });\n  }\n\n  notOneOf() {\n    const { not, notOneOf } = this.constraints;\n    const value = notOneOf || (not && (not.enum || not.oneOf));\n    return this.addConstraint(\"notOneOf\", { value });\n  }\n\n  valErrMessage(constraint) {\n    const errMsg = this.errMessages[this.key]\n      ? this.errMessages[this.key][constraint]\n      : undefined;\n    return typeof errMsg === \"function\" ? errMsg(this.constraints) : errMsg;\n  }\n\n  $const() {\n    return this;\n  }\n\n  // boolean https: //ajv.js.org/keywords.html#allof\n  $allOf() {\n    return this;\n  }\n\n  // https://ajv.js.org/keywords.html#anyof\n  $anyOf() {\n    return this;\n  }\n\n  // https: //ajv.js.org/keywords.html#oneof\n  $oneOf() {\n    return this;\n  }\n\n  // conditions https://ajv.js.org/keywords.html#not\n  $not() {\n    return this;\n  }\n\n  $if() {\n    return this;\n  }\n\n  $then() {\n    return this;\n  }\n\n  $else() {\n    return this;\n  }\n\n  message() {\n    return config.messages[this.key] || config.messages[this.type] || {};\n  }\n\n  errMessage(errKey = \"default\") {\n    return this.message[errKey] || \"error\";\n  }\n\n  toValidJSONSchema() {}\n\n  normalize() {}\n\n  deNormalize() {}\n\n  errorMsg(msg) {\n    //console.error(msg);\n    this.throwError(msg);\n  }\n\n  error(name, msg) {\n    const label = `[${name}]`;\n    const fullMsg = [label, msg].join(\" \");\n    this.errorMsg(fullMsg);\n  }\n\n  // throw ConvertYupSchemaError(fullMsg);\n  throwError(msg) {\n    throw msg;\n  }\n}\n\nexport {\n  defaults,\n  errValKeys,\n  YupMixed,\n  ConvertYupSchemaError\n};\n","// See:\n// http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.4\n\nimport { YupMixed } from './mixed';\nimport { Base } from './base';\n\nclass ArrayHandler extends Base {\n  constructor(config) {\n    super(config);\n  }\n\n  isArray(obj) {\n    if (!this.config.isArray) {\n      this.error(\"ArrayHandler: mising isArray in config\", this.config);\n    }\n    return this.config.isArray(obj);\n  }\n\n  handle(obj) {\n    return this.isArray(obj) && YupArray.create(obj).createSchemaEntry();\n  }\n}\n\nfunction toYupArray(obj, config = {}) {\n  return obj && new ArrayHandler(config).handle(obj);\n}\n\nclass YupArray extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = \"array\";\n    this.base = this.yup.array();\n    this.createYupSchemaEntry = this.config.createYupSchemaEntry;\n  }\n\n  static create(obj) {\n    return new YupArray(obj);\n  }\n\n  convert() {\n    this.maxItems();\n    this.minItems();\n    this.ensureItems();\n    this.compact();\n    // this.$uniqueItems()\n    //   .$contains()\n    //   .$additionalItems()\n    //   .$items();\n\n    // this.itemsOf()\n\n    super.convert();\n    return this;\n  }\n\n  ensureItems() {\n    return this.addConstraint(\"ensure\");\n  }\n\n  compact() {\n    return this.addConstraint(\"compact\");\n  }\n\n  // TODO: not yet implemented\n  itemsOf() {\n    return this;\n    // const { items, itemsOf } = this.constraints;\n    // const $itemsOfSchema = items || itemsOf || this.constraints.of;\n\n    // if (Array.isArray($itemsOfSchema)) {\n    //   this.error(\"itemsOf\", \"does not (yet) support an Array of schemas\");\n    // }\n\n    // if (!this.createYupSchemaEntry) {\n    //   this.warn(\n    //     \"missing createYupSchemaEntry in config, needed for recursive validation\"\n    //   );\n    //   return;\n    // }\n    // this.createYupSchemaEntry({\n    //   key: this.key,\n    //   value: $itemsOfSchema,\n    //   type: this.type,\n    //   config: this.config\n    // });\n    // $of && this.base.of($max);\n    // return this;\n  }\n\n  maxItems() {\n    const { maxItems, max } = this.constraints;\n    const $max = maxItems || max;\n    if (!this.isNumberType($max)) {\n      return this;\n    }\n    if (!this.isValidSize($max)) {\n      return this.handleInvalidSize(\"maxItems\", $max);\n    }\n    const newBase = $max && this.base.max($max);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  minItems() {\n    const { minItems, min } = this.constraints;\n    const $min = minItems || min;\n    if (!this.isNumberType($min)) {\n      return this;\n    }\n    if (!this.isValidSize($min)) {\n      return this.handleInvalidSize(\"minItems\", $min);\n    }\n    const newBase = $min && this.base.min($min);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  $items() {\n    return this;\n  }\n\n  $additionalItems() {\n    return this;\n  }\n\n  $uniqueItems() {\n    return this;\n  }\n\n  $contains() {\n    return this;\n  }\n\n  // utility\n\n  handleInvalidSize(name, value) {\n    const msg = `invalid array size constraint for ${name}, was ${value}. Must be a number >= 0`;\n    if (this.config.warnOnInvalid) {\n      this.warn(msg);\n      return this;\n    }\n    this.error(msg, value);\n    return this;\n  }\n\n  isValidSize(num) {\n    return this.isNumberType(num) && num >= 0;\n  }\n}\n\nexport {\n  toYupArray,\n  YupArray,\n  ArrayHandler\n};\n","import { YupMixed } from './mixed';\n\nclass BooleanHandler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  isBoolean(obj) {\n    return this.config.isBoolean(obj);\n  }\n\n  handle(obj) {\n    return this.isBoolean(obj) && YupBoolean.create(obj).createSchemaEntry();\n  }\n}\n\nfunction toYupBoolean(obj, config = {}) {\n  return obj && new BooleanHandler(config).handle(obj);\n}\n\nclass YupBoolean extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = \"boolean\";\n    this.base = this.yup.boolean();\n  }\n\n  static create(obj) {\n    return new YupBoolean(obj);\n  }\n}\n\nexport {\n  toYupBoolean,\n  YupBoolean\n};\n","import { NumericConstraint } from '../constraints/numeric';\n\nfunction createRangeConstraint(typer) {\n  return new RangeConstraint(typer);\n}\n\nclass RangeConstraint extends NumericConstraint {\n  constructor(typer) {\n    super(typer);\n  }\n\n  get $map() {\n    return {\n      moreThan: [\"exclusiveMinimum\", \"moreThan\"],\n      lessThan: [\"exclusiveMaximum\", \"lessThan\"],\n      max: [\"maximum\", \"max\"],\n      min: [\"minimum\", \"min\"]\n    };\n  }\n}\n\nexport {\n  createRangeConstraint,\n  RangeConstraint\n};\n","import { Constraint } from '../constraints/base';\n\nfunction createNumericConstraint(typer) {\n  return new NumericConstraint(typer);\n}\n\nclass NumericConstraint extends Constraint {\n  constructor(typer) {\n    super(typer);\n  }\n\n  transform(value) {\n    return this.typer.toNumber(value);\n  }\n\n  isValidConstraint(value) {\n    return this.typer.isNumberLike(value);\n  }\n\n  get explainConstraintValidMsg() {\n    return `Must be a number or convertible to a number`;\n  }\n}\n\nexport {\n  createNumericConstraint,\n  NumericConstraint\n};\n","import { TypeMatcher } from '../_type-matcher';\n\nclass Constraint extends TypeMatcher {\n  constructor(typer, map) {\n    super(typer.config);\n    this.map = map || this.$map || {};\n    this.typer = typer;\n    this.delegates.map(name => {\n      const delegate = typer[name];\n      if (!delegate) {\n        this.error(`missing delegate: ${name}`, {\n          typer\n        });\n      }\n      this[name] = this.isFunctionType(delegate)\n        ? delegate.bind(typer)\n        : delegate;\n    });\n  }\n\n  isStringType(val) {\n    return typeof val === \"string\";\n  }\n\n  get delegates() {\n    return [\"constraints\", \"addConstraint\", \"constraintsAdded\"];\n  }\n\n  add() {\n    const $map = this.map;\n    Object.keys($map).map(yupMethod => {\n      const names = this.entryNames($map[yupMethod]);\n      this.addConstraints(yupMethod, names);\n    });\n  }\n\n  entryNames(entry) {\n    return Array.isArray(entry) ? entry : [entry];\n  }\n\n  addConstraints(method, names = []) {\n    names.map(name => {\n      const value = this.validateAndTransform(name);\n      this.addConstraint(name, { method, value });\n    });\n    return this;\n  }\n\n  validateAndTransform(name) {\n    const cv = this.constraints[name];\n    this.validate(cv);\n    return this.transform(cv);\n  }\n\n  invalidMsg(name, value) {\n    return `invalid constraint for ${name}, was ${value}.`;\n  }\n\n  get explainConstraintValidMsg() {\n    return \"\";\n  }\n\n  invalidConstraintMsg(name, value) {\n    return [this.invalidMsg(name, value), this.explainConstraintValidMsg].join(\n      \"\\n\"\n    );\n  }\n\n  validate(cv) {\n    if (this.isNothing(cv)) {\n      return this;\n    }\n    if (!this.isValidConstraint(cv)) {\n      return this.handleInvalidConstraint(name, cv);\n    }\n  }\n\n  // override\n  isValidConstraint(value) {\n    return true;\n  }\n\n  handleInvalidConstraint(name, value) {\n    const msg = this.invalidConstraintMsg(name, value);\n    if (this.config.warnOnInvalid) {\n      this.warn(msg);\n      return this;\n    }\n    this.error(msg, value);\n    return this;\n  }\n}\n\nexport {\n  Constraint\n};\n","import { Guard } from '../_guard';\n\nclass NumberGuard extends Guard {\n  constructor(obj, config) {\n    super(obj, config);\n  }\n\n  isValid() {\n    return this.config.isNumber(this.obj);\n  }\n}\n\nfunction createNumberGuard(obj, config) {\n  return new NumberGuard(obj, config);\n}\n\nexport {\n  createNumberGuard,\n  NumberGuard\n};\n","import { Base } from './base';\n\nclass Guard extends Base {\n  constructor(obj, config) {\n    super(config);\n    this.obj = obj;\n  }\n\n  isValid() {\n    return false;\n  }\n\n  verify() {\n    return this.isPresent(this.obj) && this.isValid(this.obj);\n  }\n}\n\nexport {\n  Guard\n};\n","import { YupMixed } from '../mixed';\nimport { createRangeConstraint, RangeConstraint } from './range-constraint';\nimport { createNumberGuard, NumberGuard } from './guard';\n\nconst proceed = (obj, config = {}) => {\n  return createNumberGuard(obj, config).verify();\n};\n\nfunction toYupNumber(obj, config = {}) {\n  return proceed(obj, config) && buildYupNumber(obj);\n}\n\nfunction toYupNumberSchemaEntry(obj, config = {}) {\n  return proceed(obj, config) && buildSchemaEntry(obj);\n}\n\nfunction buildSchemaEntry(obj) {\n  return YupNumber.schemaEntryFor(obj);\n}\n\nfunction buildYupNumber(obj) {\n  return YupNumber.create(obj);\n}\n\nclass YupNumber extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = this.normalizeNumType(obj.type);\n    this.base = this.yup.number();\n    this.range = createRangeConstraint(this);\n  }\n\n  normalizeNumType(type) {\n    return type === \"int\" ? \"integer\" : type;\n  }\n\n  static create(obj) {\n    return new YupNumber(obj);\n  }\n\n  static schemaEntryFor(obj) {\n    return YupNumber.create(obj).createSchemaEntry();\n  }\n\n  get enabled() {\n    return [\"range\", \"posNeg\", \"integer\"];\n  }\n\n  convert() {\n    this.enabled.map(name => this.processConstraint(name));\n    super.convert();\n    return this;\n  }\n\n  processConstraint(name) {\n    const fn = this[name];\n    fn && typeof fn === \"function\" ? fn.bind(this)() : fn.add();\n  }\n\n  truncate() {\n    return this.addConstraint(\"truncate\");\n  }\n\n  round() {\n    const { round } = this.constraints;\n    if (this.isNothing(round)) {\n      return this;\n    }\n    const $round = this.isStringType(round) ? round : \"round\";\n    round && this.base.round($round);\n    return this;\n  }\n\n  posNeg() {\n    this.positive();\n    this.negative();\n  }\n\n  integer() {\n    this.isInteger && this.addConstraint(\"integer\");\n    return this;\n  }\n\n  get isInteger() {\n    return this.config.isInteger(this.type);\n  }\n\n  positive() {\n    return this.addConstraint(\"positive\");\n  }\n\n  negative() {\n    return this.addConstraint(\"negative\");\n  }\n\n  get isNegative() {\n    const { exclusiveMaximum, negative } = this.constraints;\n    if (negative) return true;\n    if (exclusiveMaximum === undefined) return false;\n    return exclusiveMaximum === 0;\n  }\n\n  get isPositive() {\n    const { exclusiveMinimum, positive } = this.constraints;\n    if (positive) return true;\n    if (exclusiveMinimum === undefined) return false;\n    return exclusiveMinimum === 0;\n  }\n\n  normalize() {\n    this.constraints.maximum = this.constraints.maximum || this.constraints.max;\n    this.constraints.minimum = this.constraints.minimum || this.constraints.min;\n  }\n}\n\nexport {\n  toYupNumber,\n  toYupNumberSchemaEntry,\n  YupNumber,\n  createNumberGuard,\n  NumberGuard,\n  RangeConstraint,\n  createRangeConstraint\n};\n","import { YupMixed } from './mixed';\nimport { buildYup } from '../';\n\nclass ObjectHandler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  isObject(obj) {\n    return this.config.isObject(obj);\n  }\n\n  handle(obj) {\n    return this.isObject(obj) && YupObject.create(obj).createSchemaEntry();\n  }\n}\n\nfunction toYupObject(obj, config = {}) {\n  return obj && new ObjectHandler(config).handle(obj);\n}\n\n// Allow recursive schema\nclass YupObject extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = \"object\";\n    this.base = this.yup.object();\n    this.properties = this.value.properties;\n  }\n\n  static create(obj) {\n    return new YupObject(obj);\n  }\n\n  convert() {\n    if (!this.properties) return this;\n    this.noUnknown();\n    this.camelCase().constantCase();\n\n    // recursive definition\n    if (this.value) {\n      const schema = buildYup(this.value);\n      this.base.shape(schema);\n    }\n    return this;\n  }\n\n  camelCase() {\n    return this.addConstraint(\"camelCase\");\n  }\n\n  constantCase() {\n    return this.addConstraint(\"constantCase\");\n  }\n\n  noUnknown() {\n    const { noUnknown, propertyNames } = this.value;\n    const $names = noUnknown || propertyNames;\n    const newBase =\n      $names &&\n      this.base.noUnknown(\n        $names,\n        this.valErrMessage(\"propertyNames\") || this.valErrMessage(\"noUnknown\")\n      );\n    this.base = newBase || this.base;\n    return this;\n  }\n}\n\nexport {\n  toYupObject,\n  YupObject,\n  ObjectHandler\n};\n","import { YupMixed } from './mixed';\n\nclass StringHandler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  isString(obj) {\n    return this.config.isString(obj);\n  }\n\n  handle(obj) {\n    return (\n      this.isString(obj) &&\n      YupString.create({ config: this.config, ...obj }).createSchemaEntry()\n    );\n  }\n}\n\nfunction toYupString(obj, config = {}) {\n  return obj && new StringHandler(config).handle(obj);\n}\n\nclass YupString extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = \"string\";\n    this.base = this.yup.string();\n  }\n\n  static create(obj) {\n    return new YupString(obj);\n  }\n\n  convert() {\n    super.convert();\n    this.normalize();\n    this.minLength()\n      .maxLength()\n      .pattern();\n    this.lowercase().uppercase();\n    this.email();\n    this.url();\n    this.genericFormat();\n    return this;\n  }\n\n  trim() {\n    return this.addConstraint(\"trim\");\n  }\n\n  lowercase() {\n    return this.addConstraint(\"lowercase\");\n  }\n\n  uppercase() {\n    return this.addConstraint(\"uppercase\");\n  }\n\n  genericFormat() {\n    if (!this.config.format === true) return;\n    const format = this.format;\n    if (this.yup.prototype[format]) {\n      this.addConstraint(this.format);\n    }\n  }\n\n  email() {\n    this.isEmail && this.addConstraint(\"email\");\n    return this;\n  }\n\n  get isEmail() {\n    return this.constraints.email || this.format === \"email\";\n  }\n\n  url() {\n    this.isUrl && this.addConstraint(\"url\");\n    return this;\n  }\n\n  get isUrl() {\n    return this.constraints.url || this.format === \"url\";\n  }\n\n  // todo: use NumericConstraint or RangeConstraint\n  minLength() {\n    const { minLength } = this.constraints;\n    const errMsg = this.valErrMessage(\"minLength\") || this.valErrMessage(\"min\");\n    const newBase = minLength && this.base.min(minLength, errMsg);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  // todo: use NumericConstraint or RangeConstraint\n  maxLength() {\n    const { maxLength } = this.constraints;\n    const errMsg = this.valErrMessage(\"maxLength\") || this.valErrMessage(\"max\");\n    const newBase = maxLength && this.base.max(maxLength, errMsg);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  pattern() {\n    const { pattern } = this.constraints;\n    if (!pattern) {\n      return this;\n    }\n    const regex = new RegExp(pattern);\n    const errMsg =\n      this.valErrMessage(\"pattern\") ||\n      this.valErrMessage(\"matches\") ||\n      this.valErrMessage(\"regex\");\n\n    const newBase = regex && this.base.matches(regex, errMsg);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  normalize() {\n    this.constraints.pattern =\n      this.constraints.pattern ||\n      this.constraints.matches ||\n      this.constraints.regex;\n    this.constraints.maxLength =\n      this.constraints.maxLength || this.constraints.max;\n    this.constraints.minLength =\n      this.constraints.minLength || this.constraints.min;\n  }\n}\n\nexport {\n  toYupString,\n  YupString,\n  StringHandler\n};\n","import { YupMixed } from './mixed';\n\nclass DateHandler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  isDate(obj) {\n    return this.config.isDate(obj);\n  }\n\n  handle(obj) {\n    return this.isDate(obj) && YupDate.create(obj).createSchemaEntry();\n  }\n}\n\nfunction toYupDate(obj, config = {}) {\n  return obj && new DateHandler(config).handle(obj);\n}\n\nclass YupDate extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = \"date\";\n    this.base = this.yup.date();\n  }\n\n  static create(obj) {\n    return new YupDate(obj);\n  }\n\n  convert() {\n    this.minDate().maxDate();\n    super.convert();\n    return this;\n  }\n\n  toDate(date) {\n    return new Date(date);\n  }\n\n  // Yup supports string | Date\n  // allow int (number of milliseconds from 1970) via transformToDate\n  isValidDateType(date) {\n    return this.isStringType(date) || this.isDateType(date);\n  }\n\n  isValidDate(date) {\n    if (!this.isValidDateType(date)) return false;\n    return this.isStringType(date) ? Boolean(Date.parse(date)) : true;\n  }\n\n  // optionally transform millisecs to Date value?\n  transformToDate(date) {\n    return this.isNumberType(date) ? new Date(date) : date;\n  }\n\n  minDate() {\n    const minDate = this.constraints.minDate || this.constraints.min;\n    if (this.isNothing(minDate)) {\n      return this;\n    }\n    const $minDate = this.transformToDate(minDate);\n    if (!this.isValidDateType($minDate)) {\n      return this.handleInvalidDate(\"minDate\", $minDate);\n    }\n    const newBase =\n      $minDate &&\n      this.base.min(\n        this.toDate($minDate),\n        this.valErrMessage(\"minDate\") || this.valErrMessage(\"min\")\n      );\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  maxDate() {\n    const maxDate = this.constraints.maxDate || this.constraints.max;\n    if (this.isNothing(maxDate)) {\n      return this;\n    }\n    const $maxDate = this.transformToDate(maxDate);\n    if (!this.isValidDateType($maxDate)) {\n      return this.handleInvalidDate(\"maxDate\", $maxDate);\n    }\n    const newBase =\n      $maxDate &&\n      this.base.max(\n        this.toDate($maxDate),\n        this.valErrMessage(\"maxDate\") || this.valErrMessage(\"max\")\n      );\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  handleInvalidDate(name, value) {\n    const msg = `invalid constraint for ${name}, was ${value}. Must be a number, string (valid date format) or a Date instance`;\n    if (this.config.warnOnInvalid) {\n      this.warn(msg);\n      return this;\n    }\n    this.error(msg, value);\n    return this;\n  }\n}\n\nexport {\n  toYupDate,\n  YupDate,\n  DateHandler\n};\n","import { \n  Base,\n  toYupString,\n  toYupNumberSchemaEntry,\n  toYupBoolean,\n  toYupArray,\n  toYupObject,\n  toYupDate\n} from './types';\n\nclass YupSchemaEntryError extends Error {}\n\nclass YupSchemaEntry extends Base {\n  constructor({ name, key, value, config }) {\n    super(config);\n    this.key = key;\n    this.value = value;\n    this.config = config;\n    this.name = name;\n    this.type = value.type;\n    this.types = {\n      string: toYupString,\n      number: toYupNumberSchemaEntry,\n      boolean: toYupBoolean,\n      array: toYupArray,\n      object: toYupObject,\n      date: toYupDate\n    };\n  }\n\n  isValidSchema() {\n    return typeof this.type === \"string\";\n  }\n\n  error(msg) {\n    throw new YupSchemaEntryError(msg);\n  }\n\n  toEntry() {\n    if (!this.isValidSchema()) this.error(\"Not a valid schema\");\n    const config = this.obj;\n    return (\n      this.string(config) ||\n      this.number(config) ||\n      this.boolean(config) ||\n      this.array(config) ||\n      this.object(config) ||\n      this.date(config) ||\n      this.mixed(config)\n    );\n  }\n\n  get obj() {\n    return {\n      key: this.key,\n      value: this.value,\n      type: this.type,\n      config: this.config\n    };\n  }\n\n  string(obj) {\n    return toYupString(obj || this.obj, this.config);\n  }\n\n  number(obj) {\n    return toYupNumberSchemaEntry(obj || this.obj, this.config);\n  }\n\n  boolean(obj) {\n    return toYupBoolean(obj || this.obj, this.config);\n  }\n\n  array(obj) {\n    return toYupArray(obj || this.obj, this.config);\n  }\n\n  object(obj) {\n    return toYupObject(obj || this.obj, this.config);\n  }\n\n  date(obj) {\n    return toYupDate(obj || this.obj, this.config);\n  }\n}\n\nexport {\n  YupSchemaEntryError,\n  YupSchemaEntry,\n  Base\n};\n","// - `alpha-numeric`\n// - `alpha`\n// - `ascii`\n// - `byte`\n// - `credit-card`\n// - `currency-amount`\n// - `data-uri`\n// - `date-time`\n// - `date`\n// - `domain-name`\n// - `email`\n// - `hash`\n// - `hex-color`\n// - `ipv4`\n// - `ipv6`\n// - `isbn`\n// - `magnet-uri`\n// - `mime-type`\n// - `mobile-phone`\n// - `mongo-id`\n// - `postal-code`\n// - `uri`\n// - `uuid`\n\n// const validator = require(\"validator\");\nimport dashify from 'dashify';\n\n//const camelCase = require(\"camelcase\");\nimport camelCase from 'uppercamelcase';\n\nimport { addMethod, string } from 'yup';\n\nconst toConstraintsMap = (values, opts = {}) => {\n  return values.reduce((acc, value) => {\n    if (typeof value !== \"string\" && !(value instanceof Object)) {\n      if (opts.throws !== false) {\n        throw `toConstraintsMap: invalid entry ${value}`;\n      } else {\n        return acc;\n      }\n    }\n    if (typeof value === \"string\") {\n      acc[name] = {};\n    } else {\n      if (!value.name) {\n        if (opts.throws !== false) {\n          throw `toConstraintsMap: invalid entry ${value} missing name`;\n        } else {\n          return acc;\n        }\n      }\n      acc[value.name] = value;\n    }\n    return acc;\n  }, {});\n};\n\n// const defaultConstraints = [\n//   'ascii',\n//   {\n//     name: alphanumeric,\n//     optsKey: \"locale\"\n//   },\n//   // ...\n// ]\n\nconst defaultConstraints = {\n  alphanumeric: {\n    optsKey: \"locale\"\n  },\n  alpha: {\n    optsKey: \"locale\"\n  },\n  ascii: {},\n  byte: {},\n  creditCard: {},\n  currency: {\n    opts: \"currencyOpts\"\n  },\n  dataUri: {},\n  dateTime: {},\n  date: {},\n  domainName: {\n    opts: \"domainOpts\"\n  },\n  hash: {\n    opts: \"hashAlgo\"\n  },\n  hexColor: {},\n  ipv4: {},\n  ipv6: {},\n  isbn: {},\n  magnetUri: {},\n  mimeType: {},\n  mobilePhone: {},\n  mongoId: {},\n  postalCode: {},\n  uuid: {}\n};\n\n// Template:\n// Yup.addMethod(Yup.string, \"isHexColor\", function(args) {\n//   const { message } = args;\n//   return this.test(\"hex-color\", message, function(value) {\n//     const { path, createError } = this;\n//     // [value] - value of the property being tested\n//     // [path]  - property name,\n//     // ...\n//     return validator.isHexColor(value) || createError({ path, message });\n//   });\n// });\n\nconst defaults = {\n  createValidatorName: (validatorName, key) => {\n    const name = validatorName || key;\n    validatorName = camelCase(name);\n    validatorName = validatorName.replace(/Uri$/, \"URI\");\n    validatorName = validatorName.replace(/Id$/, \"ID\");\n    return `is${validatorName}`;\n  },\n  createTestName: (testName, key) => (testName = dashify(testName || key))\n};\n\nconst fallBackFnMap = {\n  isMagnetURI: (value, isMagnetUri) => {\n    return /magnet:\\?xt=urn:[a-z0-9]+:[a-z0-9]{32}/i.test(value);\n  }\n};\n\nfunction extendYupApi({\n  constraints,\n  override = false,\n  validator,\n  createValidatorName,\n  createTestName\n} = {}) {\n  if (!validator) {\n    throw \"extendYupApi: missing validator option\";\n  }\n\n  if (Array.isArray(constraints)) {\n    constraints = toConstraintsMap(constraints);\n  }\n\n  if (!override) {\n    constraints = {\n      ...defaultConstraints,\n      ...(constraints || {})\n    };\n  } else {\n    constraints = constraints || defaultConstraints;\n  }\n\n  createValidatorName = createValidatorName || defaults.createValidatorName;\n  createTestName = createTestName || defaults.createTestName;\n\n  Object.keys(constraints).map(key => {\n    let { testName, optsKey, validatorName, logging } = constraints[key];\n    const fullValidatorName = createValidatorName(validatorName, key);\n    testName = createTestName(testName, key);\n\n    // See https://github.com/jquense/yup#yupaddmethodschematype-schema-name-string-method--schema-void\n    addMethod(string, key, (args = {}) => {\n      const { message } = args;\n      const opts = args[optsKey];\n      return string().test(testName, message, value => {\n        // return this.transform(value => {\n        const { path, createError } = this;\n        // [value] - value of the property being tested\n        // [path]  - property name,\n        // ...\n        let validatorFn = validator[fullValidatorName];\n        validatorFn = validatorFn || fallBackFnMap[fullValidatorName];\n\n        if (typeof validatorFn !== \"function\") {\n          throw Error(\"No method named ${validatorName} on validator\");\n        }\n        const valid = validatorFn(value, opts);\n        if (logging === true) {\n          console.log(\"Yup validator bridge\", {\n            key,\n            fullValidatorName,\n            testName,\n            value,\n            valid\n          });\n        }\n        return valid || createError({ path, message });\n      });\n    });\n  });\n}\n\nexport {\n  extendYupApi,\n  toConstraintsMap\n};\n","import * as yup from 'yup';\nimport { Base, YupSchemaEntry, YupSchemaEntryError } from './entry';\nimport { extendYupApi } from './validator-bridge';\n\nfunction isObject(type) {\n  return type && type === \"object\";\n}\n\nfunction buildYup(schema, config = {}) {\n  return new YupBuilder(schema, config).yupSchema;\n}\n\nfunction isObjectType(obj) {\n  return obj === Object(obj);\n}\n\nclass YupBuilder extends Base {\n  constructor(schema, config = {}) {\n    super(config);\n    this.schema = schema;\n    const type = this.getType(schema);\n    const props = this.getProps(schema);\n    this.type = type;\n    this.properties = props;\n    this.required = this.getRequired(schema);\n    if (isObject(type)) {\n      if (isObjectType(props)) {\n        const name = this.getName(schema);\n        const properties = this.normalizeRequired(schema);\n        const shapeConfig = this.propsToShape({ properties, name, config });\n        this.shapeConfig = shapeConfig;\n        this.validSchema = true;\n        return;\n      } else {\n        this.error(\n          `invalid schema: must have a properties object: ${JSON.stringify(\n            properties\n          )}`\n        );\n      }\n    } else {\n      this.error(`invalid schema: must be an object type, was: ${type}`);\n    }\n  }\n\n  getRequired(obj) {\n    const { getRequired } = this.config;\n    return getRequired ? getRequired(obj) : obj.required || [];\n  }\n\n  getProps(obj) {\n    return this.config.getProps(obj);\n  }\n\n  getType(obj) {\n    return this.config.getType(obj);\n  }\n\n  getName(obj) {\n    return this.config.getName(obj);\n  }\n\n  get yupSchema() {\n    return yup.object().shape(this.shapeConfig);\n  }\n\n  normalizeRequired() {\n    const properties = {\n      ...this.properties\n    };\n    const required = [...this.required] || [];\n    // this.logInfo(\"normalizeRequired\", {\n    //   properties,\n    //   required\n    // });\n    const propKeys = Object.keys(properties);\n    return propKeys.reduce((acc, key) => {\n      // this.logInfo(\"normalizeRequired\", {\n      //   key\n      // });\n      const value = properties[key];\n      const isRequired = required.indexOf(key) >= 0;\n      value.required = this.isRequired(value) || isRequired;\n      acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  isRequired(value) {\n    return this.config.isRequired(value);\n  }\n\n  propsToShape({ name }) {\n    const properties = {\n      ...this.properties\n    };\n    const keys = Object.keys(properties);\n    return keys.reduce((acc, key) => {\n      // this.logInfo(\"propsToShape\", {\n      //   key\n      // });\n      const value = properties[key];\n      const yupSchemaEntry = this.propToYupSchemaEntry({\n        name,\n        key,\n        value\n      });\n      this.logInfo(\"propsToShape\", { key, yupSchemaEntry });\n      acc[key] = yupSchemaEntry;\n      return acc;\n    }, {});\n  }\n\n  propToYupSchemaEntry({ name, key, value = {} }) {\n    const entryBuilder =\n      this.createYupSchemaEntry || this.config.createYupSchemaEntry;\n    return entryBuilder({ name, key, value, config: this.config });\n  }\n\n  createYupSchemaEntry({ name, key, value, config }) {\n    // return createYupSchemaEntry({ name, key, value, config });\n    return new YupSchemaEntry({\n      name,\n      key,\n      value,\n      config\n    }).toEntry();\n  }\n}\n\nimport * as types from './types';\nimport { createYupSchemaEntry } from './create-entry';\n\nexport {\n  buildYup,\n  YupBuilder,\n  YupSchemaEntry,\n  YupSchemaEntryError,\n  types,\n  createYupSchemaEntry,\n  extendYupApi\n};\n"],"names":["defaults","getProps","obj","properties","getType","type","getName","name","title","getConstraints","isString","isArray","isInteger","isBoolean","hasDateFormat","find","t","format","isDate","isNumber","isObject","isRequired","required","jsonSchemaDefaults","fields","directives","constraints","isList","date","isNullable","createYupSchemaEntry","ref","config","YupSchemaEntry","toEntry","Loggable","constructor","enable","log","console","err","error","errMsg","value","this","warn","warnMsg","logInfo","TypeMatcher","isNothing","val","isPresent","num","toNumber","Number","isNumberLike","isNaN","isNumberType","isStringType","isFunctionType","isDateType","Date","Base","Object","schemaType","ConvertYupSchemaError","Error","errValKeys","errMessages","keys","reduce","acc","key","YupMixed","validateOnCreate","yup","base","constraintsAdded","rebind","methods","map","method","bind","enabled","convertEnabled","createSchemaEntry","convert","addMappedConstraints","oneOf","notOneOf","addValueConstraint","propName","addConstraint","propValue","constraintName","constraintFn","errFn","valErrMessage","errName","constraintValue","onConstraintAdded","newBase","$map","constraintsMap","simple","enum","not","constraint","undefined","$const","$allOf","$anyOf","$oneOf","$not","$if","$then","$else","message","messages","errMessage","errKey","toValidJSONSchema","normalize","deNormalize","errorMsg","msg","throwError","fullMsg","join","ArrayHandler","handle","YupArray","create","toYupArray","array","maxItems","minItems","ensureItems","compact","itemsOf","$max","isValidSize","handleInvalidSize","max","$min","min","$items","$additionalItems","$uniqueItems","$contains","warnOnInvalid","BooleanHandler","toYupBoolean","YupBoolean","boolean","RangeConstraint","typer","moreThan","lessThan","transform","isValidConstraint","explainConstraintValidMsg","delegates","delegate","add","yupMethod","names","entryNames","addConstraints","entry","Array","validateAndTransform","cv","validate","invalidMsg","invalidConstraintMsg","handleInvalidConstraint","NumberGuard","isValid","verify","const","proceed","createNumberGuard","toYupNumberSchemaEntry","YupNumber","schemaEntryFor","buildSchemaEntry","normalizeNumType","number","range","processConstraint","fn","truncate","round","$round","posNeg","positive","negative","integer","isNegative","exclusiveMaximum","isPositive","exclusiveMinimum","maximum","minimum","ObjectHandler","toYupObject","YupObject","object","noUnknown","camelCase","constantCase","schema","buildYup","shape","$names","StringHandler","toYupString","YupString","string","minLength","maxLength","pattern","lowercase","uppercase","email","url","genericFormat","trim","prototype","isEmail","isUrl","regex","RegExp","matches","DateHandler","toYupDate","YupDate","minDate","maxDate","toDate","isValidDateType","isValidDate","Boolean","parse","transformToDate","$minDate","handleInvalidDate","$maxDate","buildYupNumber","YupSchemaEntryError","types","isValidSchema","mixed","toConstraintsMap","values","opts","throws","defaultConstraints","alphanumeric","optsKey","alpha","ascii","byte","creditCard","currency","dataUri","dateTime","domainName","hash","hexColor","ipv4","ipv6","isbn","magnetUri","mimeType","mobilePhone","mongoId","postalCode","uuid","createValidatorName","validatorName","replace","createTestName","testName","dashify","fallBackFnMap","isMagnetURI","isMagnetUri","test","YupBuilder","yupSchema","props","getRequired","normalizeRequired","shapeConfig","propsToShape","validSchema","JSON","stringify","indexOf","yupSchemaEntry","propToYupSchemaEntry","validator","override","fullValidatorName","addMethod","args","validatorFn","valid","logging","createError","path"],"mappings":"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"}