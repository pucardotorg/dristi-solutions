package org.pucar.dristi.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.egov.common.contract.request.RequestInfo;
import org.egov.tracer.model.CustomException;
import org.pucar.dristi.config.Configuration;
import org.pucar.dristi.enrichment.CaseRegistrationEnrichment;
import org.pucar.dristi.enrichment.EnrichmentService;
import org.pucar.dristi.kafka.Producer;
import org.pucar.dristi.repository.CaseRepository;
import org.pucar.dristi.repository.CaseRepositoryV2;
import org.pucar.dristi.util.*;
import org.pucar.dristi.validators.CaseRegistrationValidator;
import org.pucar.dristi.validators.EvidenceValidator;
import org.pucar.dristi.web.models.CaseSearchCriteriaV2;
import org.pucar.dristi.web.models.CaseSearchRequestV2;
import org.pucar.dristi.web.models.CourtCase;
import org.pucar.dristi.web.models.PendingAdvocateRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.util.Optional;

import static org.pucar.dristi.config.ServiceConstants.SEARCH_CASE_ERR;


@Service
@Slf4j
public class CaseServiceV2 {

    private final CaseRegistrationValidator validator;
    private final CaseRegistrationEnrichment enrichmentUtil;
    private final CaseRepository caseRepository;
    private final CaseRepositoryV2 caseRepositoryV2;
    private final WorkflowService workflowService;
    private final Configuration config;
    private final Producer producer;
    private final EtreasuryUtil etreasuryUtil;
    private final EncryptionDecryptionUtil encryptionDecryptionUtil;
    private final ObjectMapper objectMapper;
    private final CacheService cacheService;

    private final EnrichmentService enrichmentService;

    private final SmsNotificationService notificationService;

    private final IndividualService individualService;

    private final AdvocateUtil advocateUtil;
    private final TaskUtil taskUtil;
    private final HearingUtil hearingUtil;
    private final UserService userService;
    private final EvidenceUtil evidenceUtil;
    private final EvidenceValidator evidenceValidator;
    private final PaymentCalculaterUtil paymentCalculaterUtil;

    private final CaseUtil caseUtil;


    @Autowired
    public CaseServiceV2(@Lazy CaseRegistrationValidator validator,
                         CaseRegistrationEnrichment enrichmentUtil,
                         CaseRepository caseRepository, CaseRepositoryV2 caseRepositoryV2,
                         WorkflowService workflowService,
                         Configuration config,
                         Producer producer,
                         TaskUtil taskUtil,
                         EtreasuryUtil etreasuryUtil,
                         EncryptionDecryptionUtil encryptionDecryptionUtil,
                         HearingUtil analyticsUtil,
                         UserService userService,
                         PaymentCalculaterUtil paymentCalculaterUtil,
                         ObjectMapper objectMapper, CacheService cacheService, EnrichmentService enrichmentService, SmsNotificationService notificationService, IndividualService individualService, AdvocateUtil advocateUtil, EvidenceUtil evidenceUtil, EvidenceValidator evidenceValidator, CaseUtil caseUtil) {
        this.validator = validator;
        this.enrichmentUtil = enrichmentUtil;
        this.caseRepository = caseRepository;
        this.caseRepositoryV2 = caseRepositoryV2;
        this.workflowService = workflowService;
        this.config = config;
        this.producer = producer;
        this.taskUtil = taskUtil;
        this.etreasuryUtil = etreasuryUtil;
        this.encryptionDecryptionUtil = encryptionDecryptionUtil;
        this.hearingUtil = analyticsUtil;
        this.userService = userService;
        this.paymentCalculaterUtil = paymentCalculaterUtil;
        this.objectMapper = objectMapper;
        this.cacheService = cacheService;
        this.enrichmentService = enrichmentService;
        this.notificationService = notificationService;
        this.individualService = individualService;
        this.advocateUtil = advocateUtil;
        this.evidenceUtil = evidenceUtil;
        this.evidenceValidator = evidenceValidator;
        this.caseUtil = caseUtil;
    }

    public CourtCase searchCases(CaseSearchRequestV2 caseSearchRequests) {

        try {
            enrichmentUtil.enrichCaseSearchRequest(caseSearchRequests);

            CaseSearchCriteriaV2 criteria = caseSearchRequests.getCriteria();

            CourtCase courtCase = null;
            if (criteria.getCaseId() != null) {
                log.info("Searching in redis :: {}", criteria.getCaseId());
                courtCase = searchRedisCache(caseSearchRequests.getRequestInfo(), criteria.getCaseId());
            }
            if (courtCase != null) {
                log.info("CourtCase found in Redis cache for caseId: {}", criteria.getCaseId());
                validateUserPartOfCase(caseSearchRequests, courtCase);
                return courtCase;
            } else {
                log.debug("CourtCase not found in Redis cache for caseId: {}", criteria.getCaseId());
            }

            courtCase = caseRepositoryV2.getCases(criteria, caseSearchRequests.getRequestInfo());
            saveInRedisCache(courtCase, caseSearchRequests.getRequestInfo());

            CourtCase decryptedCourtCases = encryptionDecryptionUtil.decryptObject(courtCase, config.getCaseDecryptSelf(), CourtCase.class, caseSearchRequests.getRequestInfo());
            enrichAdvocateJoinedStatus(decryptedCourtCases, criteria.getAdvocateId());

            return decryptedCourtCases;

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            log.error("Error while fetching to search results :: {}", e.toString());
            throw new CustomException(SEARCH_CASE_ERR, e.getMessage());
        }
    }

    private void validateUserPartOfCase(CaseSearchRequestV2 caseSearchRequests, CourtCase courtCase) {
    }

    public CourtCase searchRedisCache(RequestInfo requestInfo, String caseId) {
        try {
            Object value = cacheService.findById(getRedisKey(requestInfo, caseId));
            log.info("Redis data received :: {}", value);
            if (value != null) {
                String caseObject = objectMapper.writeValueAsString(value);
                return objectMapper.readValue(caseObject, CourtCase.class);
            } else {
                return null;
            }
        } catch (JsonProcessingException e) {
            log.error("Error occurred while searching case in redis cache :: {}", e.toString());
            throw new CustomException(SEARCH_CASE_ERR, e.getMessage());
        }
    }

    private void enrichAdvocateJoinedStatus(CourtCase courtCase, String advocateId) {
        if (advocateId != null && courtCase.getPendingAdvocateRequests() != null) {
            Optional<PendingAdvocateRequest> foundPendingAdvocateRequest = courtCase.getPendingAdvocateRequests().stream().filter(pendingAdvocateRequest -> pendingAdvocateRequest.getAdvocateId().equalsIgnoreCase(advocateId)).findFirst();
            foundPendingAdvocateRequest.ifPresentOrElse(
                    pendingAdvocateRequest -> courtCase.setAdvocateStatus(pendingAdvocateRequest.getStatus()),
                    () -> courtCase.setAdvocateStatus("JOINED")
            );
        }
    }

    private String getRedisKey(RequestInfo requestInfo, String caseId) {
        return requestInfo.getUserInfo().getTenantId() + ":" + caseId;
    }

    public void saveInRedisCache(CourtCase courtCase, RequestInfo requestInfo) {
        cacheService.save(requestInfo.getUserInfo().getTenantId() + ":" + courtCase.getId().toString(), courtCase);
    }

}